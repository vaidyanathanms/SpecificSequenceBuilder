#---------------------------------------------------------------------
# Supporting scripts for seqbuild_main.py
# 'None' is a reserved keyword - DONT USE IT for PDB/PSF filenames
#---------------------------------------------------------------------

# Import modules
import os
import sys
import numpy
import re
import shutil
import glob
import random
import collections
import math
import subprocess
from collections import Counter
#---------------------------------------------------------------------

# General copy script
def gencpy(dum_maindir,dum_destdir,fylname):

    srcfyl = dum_maindir + '/' + fylname

    if not os.path.exists(srcfyl):
        print('ERROR: ', srcfyl, 'not found')
        return

    desfyl = dum_destdir + '/' + fylname
    shutil.copy2(srcfyl,desfyl)
#---------------------------------------------------------------------

# Set defaults
def def_vals():
    return 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2.0
#---------------------------------------------------------------------

# Check all flags 
def check_all_flags(casenum,disflag,M,N,fnamd,fpdbflag,ftopflag,\
                    fresflag,fpatflag):
    outflag = 1
    if casenum < 0:
        print('ERR: Case number not input'); outflag = -1
    elif N == 0:
        print('ERR: No chains found in input'); outflag = -1
    elif disflag == 0 and M == 0:
        print('ERR: Monodisperse systems with no MW'); outflag = -1
    elif ftopflag == 0:
        print('WARNING: Topology file not found')
    elif fresflag == 0 or fpatflag == 0:
        print('ERROR: residue/patch data missing');outflag = -1
    elif fnamd != 0 and fpdbflag == 0:
        print('ERROR: To run NAMD, input PDB/top files are required')
        outflag = -1
    return outflag
#---------------------------------------------------------------------

# Check integer
def RepresentsInt(s):
    try: 
        int(s)
        return True
    except ValueError:
        return False
#---------------------------------------------------------------------

# Define headers for psf files
def psfgen_headers(fin,topname,outname):
    fin.write(';# headers and inputs \n')
    fin.write('package require psfgen \n')
    topinp = '../' + topname
    fin.write('%s\t %s\n' %('topology',topinp))
#---------------------------------------------------------------------              

# Details for closing input files
def psfgen_postprocess(fin,writetype,iter_num,segname,fnamdflag,\
                       basic_pdb):
    # outname is already there. no need again
    fin.write(';# Writing output \n')
    fin.write('regenerate angles dihedrals \n')

    if fnamdflag:
        if writetype == 'single':
            comnt = 'Reference PDB'
            comnt2 = 'Guesses rest of the coordinates from PDB inp'
            pdbfyle =  '../' + basic_pdb
        elif writetype == 'multi':
            if iter_num == 1:
                comnt = 'Use reference PDB in the first iteration'
                pdbfyle =  '../' + basic_pdb
            else:
                comnt = '*.coor is the file generated by NAMD'
                pdbfyle = '$outputname.coor'

            comnt2 = 'Can create steric clashes and hence the iterations.'
        else:
            exit('ERROR: Unknown option: ' + writetype)
        fin.write('coordpdb %s  %s  ;#  %s\n' %(pdbfyle,segname,comnt))
        fin.write('guesscoord ;#  %s\n' %(comnt2))        
        fin.write('writepdb $outputname.pdb \n')
        if writetype == 'multi':
            fin.write('writepdb ${outputname}_${count}.pdb \n')#backup


    fin.write('writepsf $outputname.psf \n')
    if writetype == 'multi':
        fin.write('writepdb ${outputname}_${count}.psf \n')
#---------------------------------------------------------------------

# Initial PDI details if polydisperse chains are to be generated
def init_pdi_write(pdival,avgmw,nch,op_file,npdiatt,pditolval):
    pdi_fyl = 'inp_genpdi.txt'
    finit   = open(pdi_fyl,'w')
    finit.write('chain_types\n')
    finit.write('%d\n' %(1)) # for now one chain type
    finit.write('chain_details\n')
    finit.write('%g\t %g\t %g\n' %(pdival,avgmw,nch))
    finit.write('max_attempts\n')
    finit.write('%d\n' %(npdiatt))
    if pditolval != 0:
        finit.write('tolerance\n')
        finit.write('%g\n' %(pditolval))
    finit.write('pdi_op_file\n')
    finit.write('%s\n' %(op_file))
    finit.close()
#---------------------------------------------------------------------

# Compile and run PDI. 
def compile_and_run_pdi(destdir):
    
    if not os.path.exists('inp_genpdi.txt'):
        print('inp_genpdi.txt not found')
        return -1
        
    # Generate PDI data
    print("Compiling program to generate polydisperse chains...")
    print("Takes about 10 seconds..")
    if shutil.which("ifort") != None:
        subprocess.call(["ifort","-r8","pdi_dist_params.f90","pdigen.f90",\
                         "-o","pdiinp.o"])
    elif shutil.which("gfortran") != None:
       subprocess.call(["gfortran","-freal-4-real-8",\
                    "pdi_dist_params.f90","pdigen.f90","-o","pdiinp.o"])
    else:
        raise RuntimeError("No Fortran 90 compiler found!")

    print("Compilation successful..")
    subprocess.call(["./pdiinp.o", "inp_genpdi.txt"])
    return 1
#---------------------------------------------------------------------

# Assign MW for polydisperse cases
def make_polydisp_resids(inpfyle, nch):
    if not os.path.exists(inpfyle):
        print('ERR: PDI file: ', inpfyle, 'not found')
        return -1, 0
    chflag = 0
    with open(inpfyle) as fyle_pdi:
        for line in fyle_pdi:
            line = re.split('\W+',line.strip())
            if chflag == 0:
                if len(line) != 2 or line[0] != 'num_chains':
                    print('ERR: Unknown first line in: ', inpfyle)
                    print(line, '\n', len(line), line[0])
                    return -1, 0
                numch = int(line[1])
                chflag = 1
                resmw_data = []
            else:
                if int(line[0]) < 3:
                    print('ERR: Minimum 3 residues should be present')
                    return -1, 0
                resmw_data.append(int(line[0]))

    if len(resmw_data) != nch or nch != numch:
        print('ERR: Mismatch in number of chains')
        print(len(resmw_data), nch, numch)
        return -1, 0

    num_avg_mw = 0; wt_avg_mw = 0
    for mws in range(len(resmw_data)):
        num_avg_mw += resmw_data[mws]
        wt_avg_mw  += pow(resmw_data[mws],2)
    
    wt_avg_mw  = wt_avg_mw/num_avg_mw
    num_avg_mw = num_avg_mw/nch
    pdiout = wt_avg_mw/num_avg_mw

    return resmw_data, pdiout
#---------------------------------------------------------------------

# Initiate log file
def init_logwrite(flog,casenum,bmtype,Marr,segname,nch,opstyle,\
                  disflag,pdiinp,tfile = 'none'):

    flog.write('Case number: %d\n' %(casenum))
    flog.write('Creating TCL file for %s\n' %(bmtype))

    if disflag == 0:
        flog.write('Monodisperse system \n')
        flog.write('Num Chains/num Residues: %d\t%d\n'%(nch,Marr[0]))
    else:
        flog.write('Polydisperse system \n')
        for i in range(len(Marr)):
            flog.write('Chain#/Num Residues: %d\t%d\n' %(i+1,Marr[i]))

    flog.write('PDI: %g\n' %(pdiinp))
    flog.write('Tot res/pat: %d\t%d\n' %(sum(Marr),\
                                         sum(Marr)-len(Marr)))
    if tfile != 'none':
        flog.write('Input topology file: %s\n' %(tfile))
    else:
        flog.write('No topology file specified\n')        
    flog.write('Segment name in input (or output prefix): %s\n' \
               %(segname))
    flog.write('Output style: %s\n' %(opstyle))
    
    flog.write('Beginning chain generation..\n')
#---------------------------------------------------------------------

# Check initial files
def find_init_files(fpdbflag,fnamdflag,makepdifile,input_top='none',\
                    input_pdb='none'):
    # Read defaults and throw exceptions
    if not os.path.exists(input_top) and input_top != 'none':
        raise RuntimeError('Topology file not found: '+input_top)
    elif fnamdflag:
        if fpdbflag and not os.path.exists(input_pdb):
            raise RuntimeError('Initial structure file not found'+\
                               input_pdb)
    elif makepdifile == 1:
        if not os.path.exists('pdigen.f90') or \
           not os.path.exists('pdi_dist_params.f90'):
            raise RuntimeError('Source file to generate PDIs not found')
#---------------------------------------------------------------------

# Check whether the input pdb file is consistent with the inputs given
# for generating the tcl file
def check_pdb_defaults(inpfyle,defa_res,seginp):
    flag = 1 # default true
    resnum = 1
    # Check whether pdb file contains default segment and segment name
    with open(inpfyle) as fpdbin:
        for line in fpdbin:
            line = line.rstrip('\n')
            all_words = re.split('\W+',line)
            if all_words[0] == 'ATOM':
                lenwords = len(all_words)
                if all_words[lenwords-1] != seginp and \
                   all_words[lenwords-2] != seginp:
                    print(all_words[lenwords-1],all_words[lenwords-2])
                    print('Did not find ',seginp,'in ',line)
                    flag = -1
                    break
                if defa_res not in all_words:
                    print('Did not find ',defa_res,'in ',line)
                    flag = -1
                    break
                if all_words[4].isdigit():
                    if int(all_words[4]) > resnum:
                        print('WARNING: More than one res found: ',\
                              resnum)
                        resnum = int(all_words[4])
                else:
                    print('ERR: Unknown value for chain num',\
                          all_words[4])
                    flag = -1


    return flag
#---------------------------------------------------------------------
    
# Create residue sequence
def create_res_pat(nresarr,nch,segpref,flog,graft_opt,bl_type,\
                   nres_types,backbone_res,backbone_pat):

    # Write list to a log file
    flog.write(';#  Entire segment list\n')
    for i in range(nch):
        flog.write(';#  chain_id, #_residues, #_patches: %d\t%d\t%d\n'\
                   %(i+1,nresarr[i], nresarr[i]-1))
            
    sum_of_res = sum(nresarr)
    sum_of_pat = sum_of_res - nch
    flog.write('; Total residues/patches: %d\t%d\n'\
               %(sum_of_res,sum_of_pat))

    res_list = [[] for i in range(nch)] # output list of residues
    pat_list = [[] for i in range(nch)] # output list of patches
                   
    # Subtract number of branches before adding the backbone list
    if graft_opt[0]:
        br_res_ch = [] # branch residues per chain
        for chcnt in range(nch):
            deg_poly_chain = nresarr[chcnt]; br_cnt = 0
            for ival in range(3,len(graft_opt),3):
                rep_freq = int(graft_opt[ival]) #repeat frequency
                # for every branch, add one backbone mon
                br_cnt += int(deg_poly_chain/(rep_freq+1))
            br_res_ch.append(br_cnt)

    # If bl_type is single, make fractions of each block
    restot_val = 0
    if bl_type == 'single': #make 1 block with fa,fb,..
        for ival in range(1,len(backbone_res),2):
            restot_val += float(backbone_res[ival])

    # Generate list for backbone    
    for chcnt in range(nch):
        ntotmons = nresarr[chcnt]
        segname = segpref + str(chcnt+1)
        flog.write(';# chain number:\t%d\n' %(chcnt+1))
        n_bb_mons = nresarr[chcnt] - br_res_ch[chcnt]
        if n_bb_mons <= 1: #ERROR
            print('ERROR: Unphysical number of backbone monomers')
            print('Average degree of polymerization may be small')
            raise RuntimeError('ERROR: Check input')
        flog.write(';#of total/backbone/branch residues: %d\t%d\t%d\n'\
                   %(ntotmons,n_bb_mons,br_res_ch[chcnt]))
        rescntr = 0; blockcount = 0
        while rescntr < n_bb_mons: # do until total backbone residues
            restyp_cnt = 0; pattype_cnt = 0
            while restyp_cnt < nres_types: # add each residue type
                appendctr = 0
                nmax_res=ret_num_resids(backbone_res[2*restyp_cnt+1]\
                                        ,restot_val,n_bb_mons,bl_type\
                                        ,restyp_cnt,nres_types)
                if nmax_res > 1: # Set patch for this restype
                    patname = backbone_pat[pattype_cnt]
                    pattype_cnt += 1
                while appendctr <= nmax_res-1: # Build this restype
                    resname = backbone_res[2*restyp_cnt]
                    res_list[chcnt].append(resname)
                    flog.write('residue\t%d\t%s\n' \
                               %(rescntr+1,resname))
                    rescntr += 1
                    if appendctr > 0 and appendctr <= nmax_res-1 and \
                       rescntr <= n_bb_mons: 
                        # Add patch if 1) its not first residue and
                        # 2) its not last residue of a given type and
                        # 3) its not last residue of the chain
                        # NOTE: appendctr starts from 1 and hence the
                        # max condition<=nmax_res-1. Similarly for
                        # rescntr
                        pat_list[chcnt].append(patname)
                        flog.write('patch\t%s\t%s:%d\t%s:%d\n' \
                                   %(patname,segname,rescntr-1,\
                                     segname,rescntr))
                        pat_list[chcnt].append(rescntr-1)
                        pat_list[chcnt].append(rescntr)
                    appendctr += 1                       
                    if rescntr >= n_bb_mons: # exit everything
                        restyp_cnt = nres_types+2
                        appendctr  = nmax_res+2
                if restyp_cnt < nres_types-1: #patch b/w diff restypes
                    patname = backbone_pat[pattype_cnt]
                    pat_list[chcnt].append(patname)
                    flog.write('patch\t%s\t%s:%d\t%s:%d\n' \
                               %(patname,segname,rescntr,\
                                 segname,rescntr+1))
                    pat_list[chcnt].append(rescntr)
                    pat_list[chcnt].append(rescntr+1)
                    pattype_cnt += 1
                restyp_cnt += 1 # jump to next res
            if bl_type == 'multi': #end restype loop; reloop
                #patch between different blocks if the blocks do not
                #terminate 
                if restyp_cnt == nres_types:
                    patname = backbone_pat[pattype_cnt]
                    pat_list[chcnt].append(patname)
                    flog.write('patch\t%s\t%s:%d\t%s:%d\n' \
                               %(patname,segname,rescntr,\
                                 segname,rescntr+1))
                    pat_list[chcnt].append(rescntr)
                    pat_list[chcnt].append(rescntr+1)
                    pattype_cnt += 1
                restyp_cnt = 0
        # Add branches here
        if graft_opt[0]:
            for ival in range(1,len(graft_opt),3):
                rep_freq = int(graft_opt[ival+2])
                num_br   = int(ntotmons/(rep_freq+1))
                resname  = graft_opt[ival]
                patname  = graft_opt[ival+1]
                for jval in range(0,num_br):
                    bbpos = (jval+1)*rep_freq
                    res_list[chcnt].append(resname)
                    pat_list[chcnt].append(patname)
                    flog.write('residue\t%d\t%s\n'
                               %(rescntr+1,resname))
                    flog.write('patch\t%s\t%s:%d\t%s:%d\n' \
                               %(patname,segname,bbpos,\
                                 segname,rescntr+1))
                    pat_list[chcnt].append(bbpos)
                    pat_list[chcnt].append(rescntr+1)
                    rescntr += 1

    #check sum and write output
    sumval = sum(len(row) for row in res_list)
    if sumval != sum_of_res:
        print('Sum from distn,sum_of_res:',sumval,sum_of_res)
        raise RuntimeError('Sum not equal to the total # of residues')

    sumval = sum(len(row) for row in pat_list)
    if sumval/3 != sum_of_pat:
        print('Sum from distn,sum_of_pat:',sumval/3,sum_of_pat)
        raise RuntimeError('Sum not equal to the total # of patches')

    print('Succesfully generated residues & patches for all chains..')
    return res_list, pat_list
#---------------------------------------------------------------------

# Return number of residues/throw exceptions based on bl_type
def ret_num_resids(numres_str,restot_val,n_bb_mons,bl_type,restyp_cnt\
                   ,nres_types):
    if bl_type == 'single':
        f_res=float(numres_str)/restot_val
        nmax_res = int(n_bb_mons*f_res)
    else:
        nmax_res = int(numres_str)
    if bl_type == 'block' and nmax_res < 1:
        raise RuntimeError('#of residues less than 1 for '+\
                           str(2*restyp_cnt+1))
    if bl_type == 'single' and restyp_cnt == nres_types-1:
        #Adjust number of monomers for round-off errors
        if nmax_res < 1:
            print('WARNING: Round-off errors')
            print('Rounding off type: ', 2*restyp_cnt+1, '( ',\
                  nmax_res,') to 1.')
            nmax_res = 1
    return nmax_res

#---------------------------------------------------------------------
# Write residues/patches iteration by iteration
def write_multi_segments(fin,iter_num,nresthisiter,nch,chnum,\
                         segpref,res_list,patch_list,graft_opt,\
                         maxnummons):

    # Extra condition to account for the graft monomer happening at
    # the end of a PARTIAL segment. Since mth graft is attached to
    # n+1th residue (except when it is at the end of a FULL segment),
    # the n+1th residue has to be a normal residue. Since two graft
    # residues cannot be adjacent, it suffices to add n+1th residue to
    # that iteration.
    if nresthisiter != maxnummons:
        if res_list[chnum-1][nresthisiter-1] in graft_opt:
            nresthisiter += 1

    if iter_num == -1 or iter_num == 1:
        fin.write(';# Chain number: %d of %d chains\n' %(chnum,nch))
        fin.write(';# ----Begin main code -------\n')
        fin.write('\n')

    if iter_num != -1:
        fin.write(';# Iteration number: %d\n' %(iter_num))
        fin.write('set count %d' %(nresthisiter))
        fin.write('\n')


    segname = segpref + str(chnum)
    fin.write(' resetpsf \n')
    fin.write(' segment %s {\n' %(segname))

    #Residues -- indices should have -1 for first dimension  
    for rescnt in range(nresthisiter):
        fin.write('  residue  %d  %s\n' %(rescnt+1,\
                                          res_list[chnum-1][rescnt]))

    fin.write('}')        
    fin.write('\n')
    fin.write('\n')

    #Patches -- ch indices should have -1 for first dimension
    for patcnt in range(1,3*(nresthisiter-1),3):
        patchname = patch_list[chnum-1][patcnt-1]
        patchID1  = int(patch_list[chnum-1][patcnt])
        patchID2  = int(patch_list[chnum-1][patcnt+1])
        fin.write('patch  %s  %s:%d  %s:%d\n' \
                  %(patchname,segname,patchID1,segname,patchID2))

    fin.write('\n')
#---------------------------------------------------------------------

# Run generic namd script
def run_namd(fin,execfyle,inpfyle,outfyle):
    fin.write(';# Run NAMD\n')
    fin.write('%s  %s  > %s\n' %(execfyle,inpfyle,outfyle))        
    fin.write(';# exit \n')
    fin.write(';# -------------------------------------\n')
    fin.write('\n')
#---------------------------------------------------------------------

def initiate_packmol(fpin,inptype,chains,tolval):
    fpin.write('# PACKMOL melt input for %s\n' %(inptype))
    fpin.write('# Contains num chains: %d with tolerance of %g Ang\n'\
               %(chains, tolval))
    fpin.write('\n')
    fpin.write('tolerance %g\n' %(tolval))
    fpin.write('\n')

    fpin.write('# Input filetype\n')
    fpin.write('filetype pdb\n')
    fpin.write('\n')

    outname = 'melt_' + inptype + '_nch_' + str(chains) + '.pdb'
    fpin.write('# Output filename\n')
    fpin.write('output %s\n' %(outname))
    fpin.write('\n')
    fpin.write('# Adding chains\n')
#---------------------------------------------------------------------

# Make packmol input scripts
def make_packmol(fpin,structname,nrepeats,trans_list):
    fpin.write('structure %s\n' %(structname+'.pdb'))
    fpin.write('\t number %d\n' %(nrepeats))
    if trans_list != []:
        fpin.write('\t fixed')
        for k in range(6):
            fpin.write('\t %s' %(trans_list[k]))
        fpin.write('\n')
    fpin.write('end structure\n')
    fpin.write('\n')
#---------------------------------------------------------------------

# Make auxiliary files for NAMD/LigninBuilder/GROMACS
def make_auxiliary_files(tcldir,pref_pdbpsf,nch,topname):

    # bundle.tcl for generating all psf in one go
    fbund = open(tcldir + '/step1.tcl','w')
    fbund.write('# Combined file to generate psf files for all chains\n')
    fbund.write('# Use source step1.tcl from Tk console to run\n')
    
    # combine_psf.tcl() to combine psf/pdb files and write GROMACS
    # generator if neeeded
    outname = pref_pdbpsf + '_nch_' + str(nch)
    inpname = pref_pdbpsf + '_chnum_' 
    topinp = '../' + topname
    fcomb = open(tcldir + '/step2.tcl','w')
    fcomb.write('# To generate combined psf/pdb file..\n')    
    fcomb.write('package require psfgen\n')
    fcomb.write('%s %s %s\n' %('set','name',outname))
    fcomb.write('%s %s\n' %('topology',topinp))
    fcomb.write('resetpsf\n')
    fcomb.write('\n')
    fcomb.write('%s %s %s\n' %('for {set i 1} {$i <= ', str(nch), \
                             ' }  {incr i} {'))
    fcomb.write('%s %s\n' %('readpsf', inpname+str('$i.psf')))
    fcomb.write('%s %s\n' %('coordpdb', inpname+str('$i.pdb')))
    fcomb.write('}\n')
    fcomb.write('writepdb $name.pdb\n')
    fcomb.write('writepsf $name.psf\n')

    fcomb.write('exit\n')
    fcomb.close()
    
    return fbund
#---------------------------------------------------------------------
